"""Abstract base class for chat sessions."""

import abc
import copy
from typing import Any

import lair
import lair.reporting
import lair.sessions.serializer
import lair.util.prompt_template
from lair.components.history import ChatHistory
from lair.components.tools import ToolSet
from lair.logging import logger  # noqa


class BaseChatSession(abc.ABC):
    """Base class for implementing chat session functionality."""

    @abc.abstractmethod
    def __init__(self, *, history: ChatHistory | None = None, tool_set: ToolSet | None = None) -> None:
        """Initialize the chat session.

        Args:
            history: History instance to use. If ``None``, a new ``ChatHistory`` is created.
            tool_set: Tool set to use. If ``None``, a new ``ToolSet`` is created.

        """
        self.reporting: lair.reporting.Reporting = lair.reporting.Reporting()
        self.last_prompt: str | None = None
        self.last_response: str | None = None

        self.session_id: int | None = None  # Id for session management, provided by SessionManager()
        self.session_alias: str | None = None  # Alias string for session management purposes
        self.session_title: str | None = None  # Short title for the session

        self.history = history or ChatHistory()
        self.tool_set = tool_set or ToolSet()

    @abc.abstractmethod
    def invoke(
        self,
        messages: list[dict[str, Any]] | None = None,
        disable_system_prompt: bool = False,
        **kwargs: object,
    ) -> str:
        """Call the underlying model without altering state (no history)."""
        pass

    @abc.abstractmethod
    def invoke_with_tools(
        self,
        messages: list[dict[str, Any]] | None = None,
        disable_system_prompt: bool = False,
        **kwargs: object,
    ) -> tuple[str, list[dict[str, Any]]]:
        """Call the underlying model without altering state (no history)."""
        pass

    def chat(self, message: str | list[dict[str, Any]] | None = None) -> str:
        """Add a message and return the model's response.

        Args:
            message: The message to process. May be a raw string, a list of
                message dictionaries, or ``None`` to send no additional message.

        Returns:
            str: The response generated by the chat completion request.

        """
        if message:
            self._add_message_to_history(message)

        try:
            answer, tool_messages = self._invoke_chat()
        except (Exception, KeyboardInterrupt):
            self.history.rollback()
            raise

        self.last_response = answer
        self._record_response(answer, tool_messages)

        if self.session_title is None and lair.config.get("session.auto_generate_titles.enabled"):
            self.auto_generate_title()

        return answer

    def _add_message_to_history(self, message: str | list[dict[str, Any]]) -> None:
        if isinstance(message, str):
            self.history.add_message("user", message)
        elif isinstance(message, list):
            self.history.add_messages(message)

    def _invoke_chat(self) -> tuple[str, list[dict[str, Any]] | None]:
        if lair.config.get("tools.enabled"):
            return self.invoke_with_tools()
        return self.invoke(), None

    def _record_response(self, answer: str, tool_messages: list[dict[str, Any]] | None) -> None:
        if tool_messages:
            self.history.add_tool_messages(tool_messages)
        self.history.add_message("assistant", answer)
        self.history.commit()

    def auto_generate_title(self) -> str | None:
        """Generate a short title for the current session.

        Returns:
            str | None: The generated title, or ``None`` if generation failed or
            is disabled.

        """
        if self.history.num_messages() < 2 or not lair.config.get("session.auto_generate_titles.enabled"):
            return None

        user_message = None
        assistant_reply = None
        for message in self.history.get_messages():
            if not user_message and message["role"] == "user" and message["content"]:
                user_message = message["content"]
            elif not assistant_reply and message["role"] == "assistant" and message["content"]:
                assistant_reply = message["content"]

            if user_message and assistant_reply:
                break

        if not (user_message and assistant_reply):
            logger.debug(
                "auto_generate_title(): failed: Could not find a user message "
                f"and assistant reply  (session={self.session_id})"
            )
            return None

        message = self.invoke(
            disable_system_prompt=True,
            model=lair.config.get("session.auto_generate_titles.model"),
            temperature=lair.config.get("session.auto_generate_titles.temperature"),
            messages=[
                {
                    "role": "system",
                    "content": lair.util.prompt_template.fill(lair.config.get("session.auto_generate_titles.template")),
                },
                {
                    "role": "user",
                    "content": f"USER\n{user_message[:128]}\n\nASSISTANT\n{assistant_reply[:128]}",
                },
            ],
        )

        logger.debug(f"auto_generate_title(): session={self.session_id}, title={message}")
        self.session_title = message
        return message

    def get_system_prompt(self) -> str:
        """Return the filled system prompt template."""
        return lair.util.prompt_template.fill(lair.config.get("session.system_prompt_template"))

    def save_to_file(self, filename: str) -> None:
        """Persist the session state to ``filename``."""
        lair.sessions.serializer.save(self, filename)

    def load_from_file(self, filename: str) -> None:
        """Load session state from ``filename``."""
        lair.sessions.serializer.load(self, filename)

    def to_dict(self) -> dict[str, Any]:
        """Serialize the session to a dictionary."""
        return lair.sessions.serializer.session_to_dict(self)

    def update_from_dict(self, state: dict[str, Any]) -> None:
        """Update the session from a serialized state."""
        return lair.sessions.serializer.update_session_from_dict(self, state)

    @abc.abstractmethod
    def list_models(self, *, ignore_errors: bool = False) -> list[dict[str, Any]] | None:
        """Retrieve a list of available models and their metadata.

        Args:
            ignore_errors: If ``True``, errors are logged and ``None`` is
                returned instead of raising the exception.

        Returns:
            list[dict] | None: A list of dictionaries, or ``None`` if an error
            occurs and ``ignore_errors`` is ``True``.

        Raises:
            Exception: If an error occurs and ``ignore_errors`` is ``False``.

        """
        pass

    def new_session(self, preserve_alias: bool = False, preserve_id: bool = False) -> None:
        """Reset the session state.

        Args:
            preserve_alias: If ``True``, the ``session_alias`` is kept when clearing the session.
            preserve_id: If ``True``, the ``session_id`` is kept when clearing the session.

        """
        if not preserve_id:
            self.session_id = None
        if not preserve_alias:
            self.session_alias = None

        self.session_title = None
        self.last_prompt = None
        self.last_response = None
        self.history.clear()

    def import_state(self, chat_session: "BaseChatSession") -> None:
        """Import state from another chat session.

        This is used when switching session types when changing implementations.
        """
        self.session_id = chat_session.session_id
        self.session_alias = chat_session.session_alias
        self.session_title = chat_session.session_title
        self.last_prompt = chat_session.last_prompt
        self.last_response = chat_session.last_response

        self.history = copy.deepcopy(chat_session.history)
        # NOTE: Currently the old sessions tool_set is used instead of a copy.
        #     This might need to be adjusted in the future. The toolset can have multiple
        #     tools and tools can be stateful, so generating a new toolset is non-trivial.
        self.tool_set = chat_session.tool_set
